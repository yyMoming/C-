# 2 线程与数据竞争

------

## 1. C++多线程并发 

##### 	1）创建线程：

> <font color='green'>`<thread>`</font> 是`C++ 11` 中管理线程函数和类的头文件。包括类<font color='green'>`std::thread`</font> 。只要创建了线程对象（传递了 “函数名”），线程就开始了。

```c++
std::thread t1; // t1 is not a thread
std::thread t2(f1, n + 1); // pass by value
std::thread t3(f2, std::ref(n)); // pass by reference
std::thread t4(std::move(t3)); // t4 is now running f2(). t3 is no longer a thread
```

线程启动之后，要对线程运用<font color='green'>`join()`</font> 和 <font color='green'>`detach()`</font> 等类成员函数，对线程进行阻塞。

> - <font color='green'>`join()`</font> ：当调用<font color='green'>`join()`</font>，主线程等待子线程执行完之后，主线程才可以继续执行,此时主线程会释放掉执行完后的子线程资源。【你在处理某件事情（你是主线程），中途你让老王帮你办一个任务（与你同时执行）（创建线程1，该线程取名老王），又叫老李帮你办一件任务（创建线程2，该线程取名老李），现在你的一部分工作做完了，剩下的工作得用到他们的处理结果，那就调用"老王.join()"与"老李.join()"，至此你就需要等待（主线程阻塞），等他们把任务做完（子线程运行结束），你就可以继续你手头的工作了（主线程不再阻塞）】。
> - <font color='green'>`detach()`</font> ：主线程与线程分离，这样他们成为了两个独立的线程遵循 cpu 的时间片调度分配策略。子线程执行完成后会自己释放掉资源。分离后的线程，主线程将对它没有控制权。
>
> 调用 <font color='green'>`join()`</font> 会清理线程相关的存储部分，这代表了 <font color='green'>`join()`</font> 只能调用一次。使用 <font color='green'>`joinable()`</font> 来判断 <font color='green'>`join()`</font> 可否调用。同样，<font color='green'>`detach()`</font>也只能调用一次，一旦 <font color='green'>`detach()`</font> 后就无法 <font color='green'>`join()`</font> 了，有趣的是，<font color='green'>`detach()`</font>可否调用也是使用 <font color='green'>`joinable()`</font> 来判断。

