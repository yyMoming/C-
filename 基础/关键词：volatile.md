## 关键词：volatile 

------

#### 1. 首先了解 C++ 内存模型（memory model）

（Thread）中的访问都依靠主内存进行交互，即主内存中的共享变量用于线程之间的通信。但是可能会发生这样的情况：若线程中的共享变量已经改变，但未能及时更新主内存中的共享变量，因此当另一个线程要访问该线程的共享变量使取得的值不正确。这就是**“可见性问题”**。

#### 2. 可见性问题的解决方案

- 加锁（synchronizer)
- 使用关键词 **volatile**

（1）加锁

```c++
int main(){
	MyThread mythread = new MyThread();
	myThread.start();
	for(;;){
		synchronized(myThread){
			if(myThread.isFlag()){
				cout << "主进程访问到flag变量" << endl;
			}
		}
	}
}
```

加锁的作用：

​	1）主动清空本地内存

​	2）从主内存中拷贝共享变量

​	3）更新主内存中共享变量

因此，每次 thread 被访问时，都会进行上述操作，访问的线程再从主内存中获取该共享变量。

（2）使用关键词 **volatile**

在子线程中使用 **volatile** 修饰共享变量，每个线程要操作变量时会从主内存中拷贝到本地内存作为副本，当线程操作变量副本并协会主内存后，会通过 <u>CPU总线嗅探机制</u> 告知其他线程。

#### 3. volatile 的作用

> 1)	原因：编译器会自动优化代码，例如会将某些变量放到寄存器上，通过读取寄存器来加速。但是可能存在中断等问题改变RAM中的变量，但寄存器中并为被改变，因此程序无法捕捉到外部的改变。
>
> 如果一个基本变量被volatile修饰，编译器将不会把它保存到寄存器中，而是每一次都去访问内存中实际保存该变量的位置上。这一点就避免了没有volatile修饰的变量在多线程的读写中所产生的由于编译器优化所导致的灾难性问题。所以多线程中必须要共享的基本变量一定要加上volatile修饰符。当然了，volatile还能让你在编译时期捕捉到非线程安全的代码。
>
> 如果没有volatile关键字，则编译器**可能优化读取和存储**，可能暂时使用寄存器中的值，如果这个变量由别的程序更新了的话，将出现不一致的现象。

例如：如果某个按钮按下的话，就会对DSP产生中断，在按键中断程序中修改flag为1，这样上面的程序就能够得以继续运行。但是，编译器并不知道flag的值会被别的程序修改，因此在它进行优化的时候，可能会把flag的值先读入某个寄存器，然后等待那个寄存器变为1。如果不幸进行了这样的优化，那么while循环就变成了死循环，因为寄存器的内容不可能被中断服务程序修改。为了让程序每次都读取真正flag变量的值，就需要定义为如下形式：

```c
volatile short flag;
```

>一般说来，volatile用在如下的几个地方：
>1、中断服务程序中修改的供其它程序检测的变量需要加volatile；
>2、多任务环境下各任务间共享的标志应该加volatile；
>3、存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能有不同意义；

#### 4. volatile 常见问题

- 一个参数既可以是const还可以是volatile吗？为什么？

  >可以。一个例子是只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。

- 一个指针可以是volatile吗？为什么？

  >可以。

