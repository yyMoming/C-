## 关键字：inline

### 1. inline 关键词

- **产生原因**：在C/C++ 中，为了解决频繁调用小函数而消耗大量 **栈空间（栈内存，指放置程序的局部数据）**，使用 **inline** 关键词修饰后，表示 **内联函数**。

  ```
  C++ 内存分区模型
  1.代码区
  存放函数体的二进制代码（CPU执行的机器指令），由操作系统管理，包括注释
  
  2.全局区
  存放全局变量，静态变量，常量（字符串）
  
  3.栈区
  存放函数参数值和局部变量，由编译器自动分配和释放
  
  4.堆区
  由程序员分配和释放，如果程序员不释放，那么程序结束时将由操作系统回收
  ```

☆ 例1

```c++
#include <stdio.h>
inline bool greater(int v1, int v2){
	return v1 > v2;
}
int main(void){
	int v1 = 10, v2 = 20;
	return greater(v1, v2);
}
```

- **inline** 的限制：**inline** 使用是有限制的

  1）**inline** 只适合函数体内代码简单的函数，不能包含复杂结构的控制语句 while、switch等，并且不能为递归函数

  2）**inline** 只是给编译器的一个建议，编译器最终决定是否真正内联

  3）建议 **inline 函数的定义放在头文件**，声明和定义要一致。因为内联函数要在 **调用点** 展开，所以编译器必须随处可见内联函数的定义，要求每个调用了内联函数的文件都出现这个内联函数的定义。

  4）类中的成员函数默认都是 **内联的**

  5）**inline** 是一种**用于实现**的关键字：必须跟函数体放在一起才能产生 **内联**，仅在函数声明前放置 **inline** 无效



### 2. 类中内联

- 在类中定义的函数即为 **隐式内联函数**
- 仅在类中声明的函数想要成为内联函数，必须在定义处加 **inline** 关键字

```c++
class A{
public:
	void f1(){} //	定义即为隐式内联函数
	void f2(); //	仅声明
}

inline void A::f2(){} // 定义时加入 inline 变为内联函数
```

Tip：编译器对 **inline** 函数的处理步骤

​	1）将 **inline** 函数体复制到 **inline** 函数调用处

​	2）为所有 **inline** 函数中的局部变量分配内存空间

​	3）将 **inline** 函数的输入参数和返回值银蛇到调用方法的局部变量空间中

​	4）如果 **inline** 函数有多个返回点，将其转变为 **inline** 函数代码块末尾的分支

- 虚函数可以是内联函数

  1）虚函数可以是内联函数，但是**当虚函数表现多态性的时候不能内联**

  2）内联是在编译器建议编译器内联，而虚函数的多态性在运行期，**编译器无法知道运行期调用哪个代码**，因此虚函数表现为多态性时（运行期）不可以内联。

  3）**inline virtual** 唯一可以在编译器知道调用的对象是哪个类的时候使用，即编译器获得的是**实际类的对象**而非指针或引用

```c++
#include <iostream>  
using namespace std;
class Base
{
public:
    inline virtual void who()
    {
        cout << "I am Base\n";
    }
    virtual ~Base() {}
};
class Derived : public Base
{
public:
    inline void who()  // 不写inline时隐式内联
    {
        cout << "I am Derived\n";
    }
};

int main()
{
    // 此处的虚函数 who()，是通过类（Base）的具体对象（b）来调用的，编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。 
    Base b;
    b.who();

    // 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，所以不能为内联。  
    Base *ptr = new Derived();
    ptr->who();

    // 因为Base有虚析构函数（virtual ~Base() {}），所以 delete 时，会先调用派生类（Derived）析构函数，再调用基类（Base）析构函数，防止内存泄漏。
    delete ptr;
    ptr = nullptr;

    system("pause");
    return 0;
} 
```



### 3.总结：

- 只有当**函数非常短小**的时候**内联函数**才能得到我们想要的效果；但是，如果函数并不是很短而且在很多地方都被调用的话，那么将会使得可执行体的体积增大
- **如果内联函数不能增强性能，就避免使用它！**

