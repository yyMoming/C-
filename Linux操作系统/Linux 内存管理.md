# Linux 内存管理

------

## 1.  Linux 内存管理系统调用

------

| 系统调用                                     | 描述           |
| -------------------------------------------- | -------------- |
| s = bkr(addr)                                | 改变数据段大小 |
| a = mmap(addr, len, prot, flags, fd, offset) | 进行映射       |
| s = unmap(addr, len)                         | 取消映射       |



## 2. Linux 内存管理实现 —— 内存分配策略

------

1. #### 虚拟内存

> 处理器在执行指令时，会从内存中读取指令并将其`解码(decode)`，在指令解码时会获取某个位置的内容并将他存到内存中。然后处理器继续执行下一条指令。这样，处理器总是在访问存储器以获取指令和存储数据。
>
> 在虚拟内存系统中，所有的地址空间都是虚拟的而不是物理的。但是实际存储和提取指令的是物理地址，所以需要让处理器根据操作系统维护的一张表将虚拟地址转换为物理地址。为了简单的完成转换，虚拟地址和物理地址会被分为固定大小的块，称为 `页(page)`。这些页有相同大小，如果页面大小不一样的话，那么操作系统将很难管理。Alpha AXP系统上的 Linux 使用 8 KB 页面，而 Intel x86 系统上的 Linux 使用 4 KB 页面。每个页面都有一个唯一的编号，即<font color='green'>`页面框架号（PFN）`</font>。

<img src="F:\YWM_work\C++\Linux操作系统\images\进程与虚拟内存.png" alt="图片" style="zoom:50%;" />

> 虚拟地址由两部分组成：**偏移量和虚拟页框号**。每次处理器遇到虚拟地址时都会提取偏移量和虚拟页框号。处理器必须将**虚拟页框号转换为物理页号**，然后以正确的偏移量的位置访问物理页。

###### 			1）页表中的每一项均包含：① `有效标志位`-表明此页表条目是否有效； ② 该条目描述的物理页框号； ③ 访问控制信息，页面使用方式，是否可写以及是否可以执行代码

> 如果当前进程尝试访问虚拟地址，但是访问不到的话，这种情况称为 `缺页异常`，此时虚拟操作系统的错误地址和页面错误的原因将通知操作系统。

2. #### 按需分页

   > 由于物理内存要比虚拟内存少很多，因此操作系统需要注意尽量避免直接使用`低效`的物理内存。节省物理内存的一种方式是**仅加载执行程序当前使用的页面**（这何尝不是一种懒加载的思想呢？）。例如，可以运行数据库来查询数据库，在这种情况下，不是所有的数据都装入内存，只装载需要检查的数据。这种仅仅在需要时才将虚拟页面加载进内中的技术称为按需分页。

3. #### 脏页

> 如果页面已经修改过，那么操作系统必须保留该页面的内容，以便以后可以访问它。这种类型的页面被称为**脏页**，当将其从内存中移除时，它会保存在称为`交换文件`的特殊文件中。相对于处理器和物理内存的速度，对交换文件的访问非常慢，并且操作系统需要兼顾将页面写到磁盘的以及将它们保留在内存中以便再次使用。

> Linux 使用`最近最少使用(LRU)`页面老化技术来公平的选择可能会从系统中删除的页面，这个方案涉及系统中的每个页面，页面的年龄随着访问次数的变化而变化，如果某个页面访问次数多，那么该页就表示越 `年轻`，如果某个页面访问次数太少，那么该页越容易被`换出`。

4. #### 访问控制

> 页面表的每一项还包含访问控制信息，访问控制信息主要检查进程是否应该访问内存。必要时需要对内存进行`访问限制`。例如包含可执行代码的内存，自然是只读内存；操作系统不应允许进程通过其可执行代码写入数据。相比之下，包含数据的页面可以被写入，但是尝试执行该内存的指令将失败。大多数处理器至少具有两种执行模式：内核态和用户态。你不希望访问用户执行内核代码或内核数据结构，除非处理器以内核模式运行。

5. #### 缓存

   - 缓冲区缓存

     > 缓冲区高速缓存包含`块设备`驱动程序使用的数据缓冲区。
     >
     > 块设备是一个能存储`固定大小块`信息的设备，它支持**以固定大小的块，扇区或群集读取和（可选）写入数据**。每个块都有自己的`物理地址`。通常块的大小在 512 - 65536 之间。所有传输的信息都会以`连续`的块为单位。块设备的基本特征是每个块都较为对立，能够独立的进行读写。常见的块设备有 **硬盘、蓝光光盘、USB 盘**。
     >
     > 缓冲区高速缓存通过`设备标识符`和块编号用于快速查找数据块。**如果可以在缓冲区高速缓存中找到数据**，则无需从物理块设备中读取数据，这种访问方式要快得多。

   - 页缓存

     > 页缓存用于加快对磁盘上图像和数据的访问

   - 硬件缓存

     >处理器中通常使用一种硬件缓存。页表条目的缓存。在这种情况下，处理器并不总是直接读取页表，而是根据需要缓存页的翻译。这些是<font color='green'>`转换后备缓冲区` </font>也被称为<font color='green'> `TLB`</font>，包含来自系统中一个或多个进程的页表项的缓存副本。

   使用缓存也存在缺点，为了节省精力，Linux 必须使用更多的时间和空间来维护这些缓存，并且如果缓存损坏，系统将会崩溃。



## 3. Linux 页表

------

<img src="F:\YWM_work\C++\Linux操作系统\images\Linux页表.png" alt="图片" style="zoom:67%;" />

> PDG 表示<font color='green'>`全局页表`</font>，当创建一个新的进程时，都要为新进程创建一个新的页面目录，即 PGD。要将虚拟地址转换为物理地址，处理器必须获取每个级别字段的内容，将其转换为包含页表的物理页的偏移量，并读取下一级页表的页框号。这样重复三次，直到找到包含虚拟地址的物理页面的页框号为止。

- 页分配

  > 对系统中物理页面有很多需求。例如，当图像加载到内存中时，操作系统需要分配页面。

  >系统中所有物理页面均由<font color='green'> `mem_map` </font>数据结构描述，这个数据结构是 <font color='green'>`mem_map_t` </font>的列表。它包括一些重要的属性
  >
  >- count ：这是页面的用户数计数，当页面在多个进程之间共享时，计数大于 1
  >
  >- age：这是描述页面的年龄，用于确定页面是否适合丢弃或交换
  >
  >- map_nr ：这是此mem_map_t描述的物理页框号。

  > 页面分配代码使用 `free_area`向量查找和释放页面，free_area 的每个元素都包含有关页面块的信息。

- 页面取消分配

  > 存的碎片化，会将较大的空闲页面分成较小的页面。页面解除分配代码会尽可能将页面重新组合成为更大的空闲块。每释放一个页面，都会检查相同大小的相邻的块，以查看是否空闲。如果是，则将其与新释放的页面块组合以形成下一个页面大小块的新的自由页面块。每次将两个页面块重新组合为更大的空闲页面块时，页面释放代码就会尝试将该页面块重新组合为更大的空闲页面。通过这种方式，可用页面的块将尽可能多地使用内存。



## 4.  内存映射

> 内核有两种类型的内存映射：<font color='green'>`共享型(shared)` </font>和<font color='green'>`私有型(private)`</font>。私有型是当进程为了只读文件，而不写文件时使用，这时，私有映射更加高效。但是，任何对私有映射页的写操作都会导致内核停止映射该文件中的页。所以，写操作既不会改变磁盘上的文件，对访问该文件的其它进程也是不可见的。
>
> 一旦可执行映像被内存映射到虚拟内存后，它就可以被执行了。因为只将映像的开头部分物理的拉入到内存中，因此它将很快访问物理内存尚未存在的虚拟内存区域。当进程访问没有有效页表的虚拟地址时，操作系统会报告这项错误。**页面错误描述页面出错的虚拟地址和引起的内存访问（RAM）类型。**Linux 必须找到代表发生页面错误的内存区域的 vm_area_struct 结构。由于搜索 vm_area_struct 数据结构对于有效处理页面错误至关重要，因此它们以 `AVL（Adelson-Velskii和Landis）`树结构链接在一起。如果引起故障的虚拟地址没有 `vm_area_struct` 结构，则此进程已经访问了非法地址，Linux 会向进程发出 `SIGSEGV` 信号，如果进程没有用于该信号的处理程序，那么进程将会终止。